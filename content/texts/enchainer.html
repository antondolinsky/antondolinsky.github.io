<html>
  <head>
    <title>
      Chainable async interfaces
    </title>
    <link rel="stylesheet" type="text/css" href="/styles/styles.css">
  </head>
  <style>
    pre {
      font-family: monospace;
      margin: 0;
    }
    h1, h2 {
      margin: 0;
    }
    h1 {
      font-size: 28px;
      padding-bottom: 48px;
    }
    h2 {
      font-size: 18px;
      padding-top: 16px;
    }
    .text {
      font-family: Times;
      font-size: 16px;
    }
    .code {
      background-color: Black;
      color: White;
    }
    .code-light {
      font-family: Courier;
      font-size: 14px;
    }
    footer {
      font-family: Times;
      font-size: 14px;
    }
  </style>
  <body>
    <h1>Chainable Async Interfaces</h1>
    <h2>The objective</h2>
    <div class="text">
      <p>Sometimes it is convenient to be able to use the chaining style of code that is, for example, common in jQuery:</p>
      <p class="code-light">$('.someclass').attr('someattr', 3).html('somecontent').appendTo(someElement)</p>
      </p>... and so on. Each new function call returns a version of the same interface, so the calls can be chained. However, this does not work well with asynchronous code, since each function runs as soon as the previous one has returned.</p>
      <p>The chaining style can of course also be done asynchronously by using Promises. Let's say that <i>promise</i> is some promise. Then we can write:
      <p class="code-light">promise.then(function() { ... }).then(function() { ... }).then(function() { ... })</p>
      <p>... and so on. We can continue to add new calls to <i>then</i> as much as necessary. But if we want to chain promises like this, we have to always use <i>then</i> as the function call, and we always have to pass in a function to <i>then</i>, and we have to return a new Promise each time from <i>then</i>.</p>
      <p>It would be convenient if we could chain arbitrary function calls, pass in arbitrary arguments, and ensure that the chained functions could each do asynchronous execution, with the next function in the chain only running when the previous ones had completed.</p>
      <p>It would be nice, in other words, to be able to do the following:</p>
      <p class="code-light">makechain().someFuncThatDoesAsyncStuff(...some args...).someOtherFuncThatDoesAsyncStuff(...some args...).thirdFunc(...some args...)</p>
      <p>... and so on.</p>
      <p>The following code aims to achieve this by wrapping a Promise in an interface that returns a Proxy. (So, of course, a Promise and Proxy-supporting JS environment is required.)
    </div>
    <h2>Main code</h2>
    <pre>
      <div class="code">
        function chain(promise, func) {
          if (! promise) {
            promise = new Promise(function(next) {
              next();
            });
          }
          return new Proxy({}, {
            get: function(state, key, proxy) {
              if (key === '') {
                return promise;
              } else {
                return function() {
                  var callArgs = Array.prototype.slice.call(arguments);
                  promise = promise.then(function() {
                    var prevArgs = Array.prototype.slice.call(arguments);
                    return new Promise(function(next) {
                      func({
                        next: next,
                        prevArgs: prevArgs,
                        callArgs: callArgs,
                        key: key,
                        state: state,
                        promise: promise,
                        proxy: proxy
                      });
                    });
                  });
                  return proxy;
                };
              }
            }
          });
        };
      </div>
    </pre>
    <h2>How it works</h2>
    <div class="text">

    </div>
    <h2>Example: MySQL interface</h2>
    <div>
      <p>This example is designed to run in Node and uses Felix Geisend√∂rfer's <a href="https://github.com/mysqljs/mysql">mysql</a> module (you can install it by running <span class="code-light">npm install mysql</span>).</p>
    </div>
    <pre>
      <div class="code">
        var mysql = require('mysql')

        function chain(promise, func) {
          if (! promise) {
            promise = new Promise(function(next) {
              next();
            });
          }
          return new Proxy({}, {
            get: function(state, key, proxy) {
              if (key === '') {
                return promise;
              } else {
                return function() {
                  var callArgs = Array.prototype.slice.call(arguments);
                  promise = promise.then(function() {
                    var prevArgs = Array.prototype.slice.call(arguments);
                    return new Promise(function(next) {
                      func({
                        next: next,
                        prevArgs: prevArgs,
                        callArgs: callArgs,
                        key: key,
                        state: state,
                        promise: promise,
                        proxy: proxy
                      });
                    });
                  });
                  return proxy;
                };
              }
            }
          });
        };

        /* Setting up mysql handler that will use a chainable async interface */

        var mysqlhandler = (function() {
          var methods = {
            setup: function(args) {
              var setupArgs = args.callArgs[0];
              args.state.pool = mysql.createPool(setupArgs);
              args.state.queryResults = {};
              args.next();
            },
            query: function(args) {
              var queryArgs = args.callArgs[0];
              function done(err, results) {
                args.state.queryResults[queryArgs.name] = (err ? err : results);
                args.next();
              };
              args.state.pool.getConnection(function(err, connection) {
                if (err) {
                  done(err);
                } else {
                  var query = connection.query({
                    sql: queryArgs.sql
                  }, done);
                }
              });
            },
            get: function(args) {
              var cb = args.callArgs[0];
              cb(args.next, args.state.queryResults);
            }
          }
          return function(setupArgs) {
            return chain(null, function(args) {
              methods[args.key](args)
            }).setup(setupArgs);
          };
        })();

        /* Now making an instance of the mysqlhandler and using it (change the provided database 
        connection settings such as user, password, etc. if necessary) */

        var handler = mysqlhandler({
          host: '127.0.0.1',
          user: 'test',
          password: 'test',
          port: 3306,
          poolNumber: 10
        }).query({
          name: 'query_1',
          sql: 'CREATE DATABASE testdatabase'
        }).query({
          name: 'query_2',
          sql: 'CREATE TABLE testdatabase.testtable (testfield TEXT)'
        }).query({
          name: 'query_3',
          sql: 'INSERT INTO testdatabase.testtable SET testfield = "sometext"'
        }).query({
          name: 'query_4',
          sql: 'SELECT * FROM testdatabase.testtable'
        }).query({
          name: 'query_5',
          sql: 'DROP DATABASE testdatabase'
        }).get(function(next, queryResults) {
          /* queryResults will be an object with the query 'names' as keys as the query results as values */
          console.log(queryResults);
          process.exit();
        });
     </div>
    </pre>
    <h2>Example: Using the chain with async/await</h2>
    <div class="text">
      <p>The chain can be used with <i>async</i>/<i>await</i> (or with generators). Reading the empty string property from the proxy returned by a chain returns the promise internal to the chain. This is designed so that the promise can then be given to an <i>await</i> statement (or, if using a generator, to a <i>yield</i> statement</p>
    </div>
    <pre>
      <div class="code">
        function chain(promise, func) {
          if (! promise) {
            promise = new Promise(function(next) {
              next();
            });
          }
          return new Proxy({}, {
            get: function(state, key, proxy) {
              if (key === '') {
                return promise;
              } else {
                return function() {
                  var callArgs = Array.prototype.slice.call(arguments);
                  promise = promise.then(function() {
                    var prevArgs = Array.prototype.slice.call(arguments);
                    return new Promise(function(next) {
                      func({
                        next: next,
                        prevArgs: prevArgs,
                        callArgs: callArgs,
                        key: key,
                        state: state,
                        promise: promise,
                        proxy: proxy
                      });
                    });
                  });
                  return proxy;
                };
              }
            }
          });
        };

        var p = chain(null, function(args) {
          var key = args.key;
          var waitTime = args.callArgs[0];
          console.log('function named', key, 'has been called with first argument', waitTime);
          setTimeout(function() {
            args.next(key);
          }, waitTime);
        });

        /* p is now a chain instance */

        (async function() {
          p.func_one(1000).func_two(2000).func_three(500);
          var await_1 = await p[''];                                      /* p[''] returns the promise internal to 'p' */
          console.log('The last func called was named:', await_1);
          p.func_four(4000).func_five(300);
          var await_2 = await p[''];
          console.log('The last func called was named:', await_2);
        })();
      </div>
    </pre>
    <footer>By Anton Dolinsky<br>Created on May 31 2017</footer>
  </body>
</html>